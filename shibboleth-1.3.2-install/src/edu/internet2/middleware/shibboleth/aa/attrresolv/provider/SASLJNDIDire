/*
 * Copyright [2005] [University Corporation for Advanced Internet Development, Inc.]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package edu.internet2.middleware.shibboleth.aa.attrresolv.provider;

import java.io.IOException;
import java.security.GeneralSecurityException;
import java.security.Principal;
import java.security.PrivilegedAction;
import java.security.SecureRandom;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Properties;
import java.util.Set;
import java.util.StringTokenizer;

import javax.naming.CommunicationException;
import javax.naming.Context;
import javax.naming.NamingEnumeration;
import javax.naming.NamingException;
import javax.naming.directory.Attribute;
import javax.naming.directory.Attributes;
import javax.naming.directory.BasicAttribute;
import javax.naming.directory.BasicAttributes;
import javax.naming.directory.InitialDirContext;
import javax.naming.directory.SearchControls;
import javax.naming.directory.SearchResult;
import javax.naming.ldap.InitialLdapContext;
import javax.naming.ldap.LdapContext;
import javax.naming.ldap.StartTlsRequest;
import javax.naming.ldap.StartTlsResponse;
import javax.net.ssl.KeyManager;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSocketFactory;
import javax.security.auth.Subject;
import javax.security.auth.login.LoginContext;
import javax.security.auth.login.LoginException;

import org.apache.log4j.Logger;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;

import edu.internet2.middleware.shibboleth.aa.attrresolv.AttributeResolver;
import edu.internet2.middleware.shibboleth.aa.attrresolv.DataConnectorPlugIn;
import edu.internet2.middleware.shibboleth.aa.attrresolv.Dependencies;
import edu.internet2.middleware.shibboleth.aa.attrresolv.ResolutionPlugInException;
import edu.internet2.middleware.shibboleth.common.Credential;
import edu.internet2.middleware.shibboleth.common.Credentials;

/**
 * <code>DataConnectorPlugIn</code> implementation that utilizes a user-specified JNDI <code>DirContext</code> to
 * retrieve attribute data.  Authentication to the LDAP directory is done via the GSS-API (kerberos).
 * 
 * @author Walter Hoehn (wassa@columbia.edu)
 * @author Scotty Logan (swl@stanford.edu)
 */
public class SASLJNDIDirectoryDataConnector extends BaseDataConnector implements DataConnectorPlugIn, PrivilegedAction {

	private static Logger log = Logger.getLogger(SASLJNDIDirectoryDataConnector.class.getName());
	protected String searchFilter;
	protected Properties properties;
	protected SearchControls controls;
	protected boolean mergeMultiResults = false;
	protected boolean startTls = false;
	protected boolean noResultsIsError = true;
	boolean useExternalAuth = false;
	private SSLSocketFactory sslsf;
        protected Principal principal;
        protected String requester;
        protected String responder;
        protected Dependencies depends;

	/**
	 * Constructs a DataConnector based on DOM configuration.
	 * 
	 * @param e
	 *            a &lt;JNDIDirectoryDataConnector /&gt; DOM Element as specified by urn:mace:shibboleth:resolver:1.0
	 * @throws ResolutionPlugInException
	 *             if the PlugIn cannot be initialized
	 */
	public SASLJNDIDirectoryDataConnector(Element e) throws ResolutionPlugInException {

		super(e);

		// Decide if we are using starttls
		String tlsAttribute = e.getAttribute("useStartTls");
		if (tlsAttribute != null && tlsAttribute.equalsIgnoreCase("TRUE")) {
			startTls = true;
			log.debug("Start TLS support enabled for connector.");
		}
		
		// Decide if no results is an error or not
		String noResultErrorAttribute = e.getAttribute("noResultsIsError");
		if (noResultErrorAttribute != null && noResultErrorAttribute.equalsIgnoreCase("FALSE")) {
			noResultsIsError = false;
			log.debug("No search results will not be treated as an error");
		}

		// Do we merge the attributes in the event of multiple results from a search?
		String mergeMultiResultsAttrib = e.getAttribute("mergeMultipleResults");
		if (mergeMultiResultsAttrib != null && mergeMultiResultsAttrib.equalsIgnoreCase("TRUE")) {
			mergeMultiResults = true;
			log.debug("Multiple searcg result merging enabled for connector.");
		}

		// Determine the search filter and controls
		NodeList searchNodes = e.getElementsByTagNameNS(AttributeResolver.resolverNamespace, "Search");
		if (searchNodes.getLength() != 1) {
			log.error("JNDI Directory Data Connector requires a \"Search\" specification.");
			throw new ResolutionPlugInException("JNDI Directory Data Connector requires a \"Search\" specification.");
		}

		String searchFilterSpec = ((Element) searchNodes.item(0)).getAttribute("filter");
		if (searchFilterSpec != null && !searchFilterSpec.equals("")) {
			searchFilter = searchFilterSpec;
			log.debug("Search Filter: (" + searchFilter + ").");
		} else {
			log.error("Search spec requires a filter attribute.");
			throw new ResolutionPlugInException("Search spec requires a filter attribute.");
		}

		defineSearchControls(((Element) searchNodes.item(0)));

		// Load JNDI properties
		NodeList propertyNodes = e.getElementsByTagNameNS(AttributeResolver.resolverNamespace, "Property");
		properties = new Properties(System.getProperties());
		for (int i = 0; propertyNodes.getLength() > i; i++) {
			Element property = (Element) propertyNodes.item(i);
			String propName = property.getAttribute("name");
			String propValue = property.getAttribute("value");

			log.debug("Property: (" + propName + ").");
			log.debug("   Value: (" + propValue + ").");

			if (propName == null || propName.equals("")) {
				log.error("Property (" + propName + ") is malformed.  Connot accept empty property name.");
				throw new ResolutionPlugInException("Property is malformed.");
			} else if (propValue == null || propValue.equals("")) {
				log.error("Property (" + propName + ") is malformed.  Cannot accept empty property value.");
				throw new ResolutionPlugInException("Property is malformed.");
			} else {
				properties.setProperty(propName, propValue);
			}
		}

		// Fail-fast connection test
		InitialDirContext context = null;
		try {
			if ("GSSAPI".equals(properties.getProperty(Context.SECURITY_AUTHENTICATION))) {
			    // do nothing for now;
			} else if (!startTls) {
				try {
					log.debug("Attempting to connect to JNDI directory source as a sanity check.");
					context = initConnection();
				} catch (IOException ioe) {
					log.error("Failed to startup directory context: " + ioe);
					throw new ResolutionPlugInException("Failed to startup directory context.");
				}
			} else {
				// UGLY!
				// We can't do SASL EXTERNAL auth until we have a TLS session
				// So, we need to take this out of the environment and then stick it back in later
				if ("EXTERNAL".equals(properties.getProperty(Context.SECURITY_AUTHENTICATION))) {
					useExternalAuth = true;
					properties.remove(Context.SECURITY_AUTHENTICATION);
				}

				// If TLS credentials were supplied, load them and setup a KeyManager
				KeyManager keyManager = null;
				NodeList credNodes = e.getElementsByTagNameNS(Credentials.credentialsNamespace, "Credential");
				if (credNodes.getLength() > 0) {
					log.debug("JNDI Directory Data Connector has a \"Credential\" specification.  "
							+ "Loading credential...");
					Credentials credentials = new Credentials((Element) credNodes.item(0));
					Credential clientCred = credentials.getCredential();
					if (clientCred == null) {
						log.error("No credentials were loaded.");
						throw new ResolutionPlugInException("Error loading credential.");
					}
					keyManager = new KeyManagerImpl(clientCred.getPrivateKey(), clientCred.getX509CertificateChain());
				}

				try {
					// Setup a customized SSL socket factory that uses our implementation of KeyManager
					// This factory will be used for all subsequent TLS negotiation
					SSLContext sslc = SSLContext.getInstance("TLS");
					sslc.init(new KeyManager[]{keyManager}, null, new SecureRandom());
					sslsf = sslc.getSocketFactory();

					log.debug("Attempting to connect to JNDI directory source as a sanity check.");
					initConnection();
				} catch (GeneralSecurityException gse) {
					log.error("Failed to startup directory context.  Error creating SSL socket: " + gse);
					throw new ResolutionPlugInException("Failed to startup directory context.");

				} catch (IOException ioe) {
					log.error("Failed to startup directory context.  Error negotiating Start TLS: " + ioe);
					throw new ResolutionPlugInException("Failed to startup directory context.");
				}
			}

			log.debug("JNDI Directory context activated.");

		} catch (NamingException ne) {
			log.error("Failed to startup directory context: " + ne);
			throw new ResolutionPlugInException("Failed to startup directory context.");
		} finally {
			try {
				if (context != null) {
					context.close();
				}
			} catch (NamingException ne) {
				log.error("An error occured while closing the JNDI context: " + e);
			}

		}
	}

	/**
	 * Create JNDI search controls based on DOM configuration
	 * 
	 * @param searchNode
	 *            a &lt;Controls /&gt; DOM Element as specified by urn:mace:shibboleth:resolver:1.0
	 */
	protected void defineSearchControls(Element searchNode) {

		controls = new SearchControls();

		NodeList controlNodes = searchNode.getElementsByTagNameNS(AttributeResolver.resolverNamespace, "Controls");
		if (controlNodes.getLength() < 1) {
			log.debug("No Search Control spec found.");
		} else {
			if (controlNodes.getLength() > 1) {
				log.error("Found multiple Search Control specs for a Connector.  Ignoring all but the first.");
			}

			String searchScopeSpec = ((Element) controlNodes.item(0)).getAttribute("searchScope");
			if (searchScopeSpec != null && !searchScopeSpec.equals("")) {
				if (searchScopeSpec.equals("OBJECT_SCOPE")) {
					controls.setSearchScope(SearchControls.OBJECT_SCOPE);
				} else if (searchScopeSpec.equals("ONELEVEL_SCOPE")) {
					controls.setSearchScope(SearchControls.ONELEVEL_SCOPE);
				} else if (searchScopeSpec.equals("SUBTREE_SCOPE")) {
					controls.setSearchScope(SearchControls.SUBTREE_SCOPE);
				} else {
					try {
						controls.setSearchScope(Integer.parseInt(searchScopeSpec));
					} catch (NumberFormatException nfe) {
						log.error("Control spec included an invalid (searchScope) attribute value.");
					}
				}
			}
			
			String returningAttributesStr = ((Element) controlNodes.item(0)).getAttribute("returningAttributes");
			if(returningAttributesStr != null && !returningAttributesStr.equals("")){
				StringTokenizer attributes = new StringTokenizer(returningAttributesStr, ",");
				String[] returningAttributes = new String[attributes.countTokens()];
				for(int i = 0; attributes.hasMoreTokens(); i++){
					returningAttributes[i] = attributes.nextToken().trim();
				}
				
				controls.setReturningAttributes(returningAttributes);
			}

			String timeLimitSpec = ((Element) controlNodes.item(0)).getAttribute("timeLimit");
			if (timeLimitSpec != null && !timeLimitSpec.equals("")) {
				try {
					controls.setTimeLimit(Integer.parseInt(timeLimitSpec));
				} catch (NumberFormatException nfe) {
					log.error("Control spec included an invalid (timeLimit) attribute value.");
				}
			}

			String returningObjectsSpec = ((Element) controlNodes.item(0)).getAttribute("returningObjects");
			if (returningObjectsSpec != null && !returningObjectsSpec.equals("")) {
				controls.setReturningObjFlag(new Boolean(returningObjectsSpec).booleanValue());
			}

			String linkDereferencingSpec = ((Element) controlNodes.item(0)).getAttribute("linkDereferencing");
			if (linkDereferencingSpec != null && !linkDereferencingSpec.equals("")) {
				if (linkDereferencingSpec != null && !linkDereferencingSpec.equals("")) {
					controls.setDerefLinkFlag(new Boolean(linkDereferencingSpec).booleanValue());
				}
			}

			String countLimitSpec = ((Element) controlNodes.item(0)).getAttribute("countLimit");
			if (countLimitSpec != null && !countLimitSpec.equals("")) {
				try {
					controls.setCountLimit(Long.parseLong(countLimitSpec));
				} catch (NumberFormatException nfe) {
					log.error("Control spec included an invalid (countLimit) attribute value.");
				}
			}
		}

		if (log.isDebugEnabled()) {
			log.debug("Search Control (searchScope): " + controls.getSearchScope());
			log.debug("Search Control (returningAttributes): " + controls.getReturningAttributes());
			log.debug("Search Control (timeLimit): " + controls.getTimeLimit());
			log.debug("Search Control (returningObjects): " + controls.getReturningObjFlag());
			log.debug("Search Control (linkDereferencing): " + controls.getDerefLinkFlag());
			log.debug("Search Control (countLimit): " + controls.getCountLimit());
		}
	}

	/**
	 * @see edu.internet2.middleware.shibboleth.aa.attrresolv.DataConnectorPlugIn#resolve(java.security.Principal,
	 *      java.lang.String, java.lang.String, edu.internet2.middleware.shibboleth.aa.attrresolv.Dependencies)
	 */
	protected Attributes resolve_worker(Principal principal, String requester, String responder, Dependencies depends)
			throws ResolutionPlugInException {

		InitialDirContext context = null;
		NamingEnumeration nEnumeration = null;
		String populatedSearch = searchFilter.replaceAll("%PRINCIPAL%", principal.getName());
		try {
			try {
				context = initConnection();
				nEnumeration = context.search("", populatedSearch, controls);

				// If we get a failure during the init or query, attempt once to re-establish the connection
			} catch (CommunicationException e) {
				log.debug(e);
				log.warn("Encountered a connection problem while querying for attributes.  Re-initializing "
						+ "JNDI context and retrying...");
				context = initConnection();
				nEnumeration = context.search("", populatedSearch, controls);
			} catch (IOException e) {
				log.debug(e);
				log.warn("Encountered a connection problem while querying for attributes.  Re-initializing "
						+ "JNDI context and retrying...");
				context = initConnection();
				nEnumeration = context.search("", populatedSearch, controls);
			}

			if (nEnumeration == null || !nEnumeration.hasMore() && noResultsIsError) {
				log.error("Could not locate a principal with the name (" + principal.getName() + ").");
				throw new ResolutionPlugInException("No data available for this principal.");
			}

			SearchResult result = (SearchResult) nEnumeration.next();
			Attributes attributes = result.getAttributes();

			if (!mergeMultiResults) {
				if (nEnumeration.hasMore()) {
					log.error("Multiple results returned from filter " + searchFilter + " for principal " + principal
							+ ", only one expected.");
					throw new ResolutionPlugInException("Multiple results returned when only one expected.");
				}
			} else {
				log.debug("Multiple results returned by filter " + populatedSearch
						+ " merging attributes from each result");
				attributes = mergeResults(nEnumeration, attributes);
			}

			// For Sun's ldap provider only, construct the dn of the returned entry and manually add that as an
			// attribute
			if (context.getEnvironment().get(Context.INITIAL_CONTEXT_FACTORY)
					.equals("com.sun.jndi.ldap.LdapCtxFactory")) {
				
			    // Check to see if the context was built with an empty base DN, if so don't try to append it
                // otherwise we'll end up with a malformed DN (it'll contain a trailing comma).
                String dnStr;
                if(context.getNameInNamespace() == null || context.getNameInNamespace().length() ==0) {
                    dnStr = result.getName();
                }else {
                    dnStr =  result.getName() + "," + context.getNameInNamespace();
                }
                
                BasicAttribute dn = new BasicAttribute("dn", dnStr);
				attributes.put(dn);
			}

			return attributes;

		} catch (NamingException e) {
			log.error("An error occurred while retieving data for principal (" + principal.getName() + ") :"
					+ e.getMessage());
			throw new ResolutionPlugInException("Error retrieving data for principal.");
		} catch (IOException e) {
			log.error("An error occurred while retieving data for principal (" + principal.getName() + ") :"
					+ e.getMessage());
			throw new ResolutionPlugInException("Error retrieving data for principal.");

		} finally {
			try {
				if (context != null) {
					context.close();
				}
				if (nEnumeration != null) {
					nEnumeration.close();
				}
			} catch (NamingException e) {
				log.error("An error occured while closing the JNDI context: " + e);
			}
		}
	}

	public Attributes resolve(Principal principal, String requester, String responder, Dependencies depends)
			throws ResolutionPlugInException {

	    Attributes attrs = null;

	    if ("GSSAPI".equals(properties.getProperty(Context.SECURITY_AUTHENTICATION))) {
		log.debug("Setting up LoginContext");
		LoginContext loginCtx = null;
		try {
		    loginCtx = new LoginContext("Shibboleth-IdP");
		} catch (LoginException e) {
		    log.error(this.getClass().getName() + "Failed to establish SASL session:");
		    log.error(this.getClass().getName() + e.getMessage());
		    throw new ResolutionPlugInException("Failed to establish SASL session");
		}
		log.debug(this.getClass().getName() + "Logging in");
		try {
		    loginCtx.login();
		} catch (LoginException e) {
		    log.error(this.getClass().getName() + "Login failed:");
		    log.error(this.getClass().getName() + e.getMessage());
		    throw new ResolutionPlugInException("Login failed");
		}
		
		log.debug("Calling SearchAction");
		try {
		    this.principal = principal;
		    this.requester = requester;
		    this.responder = responder;
		    this.depends = depends;
		    
		    attrs = (Attributes) Subject.doAs(loginCtx.getSubject(), this);
		    } catch (Exception e) {
		    log.error("Failed to establish SASL session: " + e.getMessage());
		    //	    e.printStackTrace();
		}
	    } else {
		attrs = resolve_worker(principal, requester, responder, depends);
	    }
	    return attrs;
	}

	/**
	 * Merges the attributes found in each result and a base Attributes object. If a named attribute appears in more
	 * than one result it's values are added to any existing values already in the given Attributes object. Duplicate
	 * attribute values are eliminated.
	 * 
	 * @param searchResults
	 *            the search result
	 * @param attributes
	 *            the container to add the attributes from the search result to (may already contain attributes)
	 * @return all the attributes and values merged from search results and initial attributes set
	 * @throws NamingException
	 *             thrown if there is a problem reading result data
	 */
	private Attributes mergeResults(NamingEnumeration searchResults, Attributes attributes) throws NamingException {

		HashMap attributeMap = new HashMap();

		mergeAttributes(attributeMap, attributes);

		SearchResult result;
		while (searchResults.hasMore()) {
			result = (SearchResult) searchResults.next();
			mergeAttributes(attributeMap, result.getAttributes());
		}

		Attributes mergedAttribs = new BasicAttributes(false);
		Attribute mergedAttrib;
		Iterator attribNames = attributeMap.keySet().iterator();
		Iterator attribValues;
		String attribName;
		while (attribNames.hasNext()) {
			attribName = (String) attribNames.next();
			mergedAttrib = new BasicAttribute(attribName, false);
			Set valueSet = (Set) attributeMap.get(attribName);
			attribValues = valueSet.iterator();
			while (attribValues.hasNext()) {
				mergedAttrib.add(attribValues.next());
			}
			mergedAttribs.put(mergedAttrib);
		}

		return mergedAttribs;
	}

	/**
	 * Merges a given collection of Attributes into an existing collection.
	 * 
	 * @param attributeMap
	 *            existing collection of attribute data
	 * @param attributes
	 *            collection of attribute data to be merged in
	 * @throws NamingException
	 *             thrown if there is a problem getting attribute information
	 */
	private void mergeAttributes(HashMap attributeMap, Attributes attributes) throws NamingException {

		if (attributes == null || attributes.size() <= 0) {
			// In case the search result this came from was empty
			return;
		}

		HashSet valueSet;
		NamingEnumeration baseAttribs = attributes.getAll();
		Attribute baseAttrib;
		while (baseAttribs.hasMore()) {
			baseAttrib = (Attribute) baseAttribs.next();
			if (attributeMap.containsKey(baseAttrib.getID())) {
				valueSet = (HashSet) attributeMap.get(baseAttrib.getID());
			} else {
				valueSet = new HashSet();
			}
			for (int i = 0; i < baseAttrib.size(); i++) {
				valueSet.add(baseAttrib.get(i));
			}
			attributeMap.put(baseAttrib.getID(), valueSet);
		}
	}

	private InitialDirContext initConnection() throws NamingException, IOException, ResolutionPlugInException {

		InitialDirContext context = null;
		if (!startTls) {
			context = new InitialDirContext(properties);
		} else {
			context = new InitialLdapContext(properties, null);
			if (!(context instanceof LdapContext)) {
				log.error("Directory context does not appear to be an implementation of LdapContext.  "
						+ "This is required for startTls.");
				throw new ResolutionPlugInException("Start TLS is only supported for implementations of LdapContext.");
			}
			StartTlsResponse tls = (StartTlsResponse) ((LdapContext) context).extendedOperation(new StartTlsRequest());
			tls.negotiate(sslsf);
			if (useExternalAuth) {
				context.addToEnvironment(Context.SECURITY_AUTHENTICATION, "EXTERNAL");
			}
		}
		return context;
	}

    public Object run() {

	log.debug("resolving attributes in a SASL context");
	Attributes attrs = null;

	try {

	    attrs = resolve_worker(principal, requester, responder, depends);

	} catch (Exception e) {
	    attrs = null;
	    log.debug(e);
	    log.warn("Caught an exception while calling resolve_worker in a SASL context");
	}

	return attrs;
    }
}