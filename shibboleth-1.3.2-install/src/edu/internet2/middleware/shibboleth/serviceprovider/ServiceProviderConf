/*
 * Copyright [2005] [University Corporation for Advanced Internet Development, Inc.]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * ServiceProviderConfig.java
 * 
 * A ServiceProviderConfig object holds an instance of the Shibboleth
 * configuration data from the main configuration file and from all
 * secondary files referenced by the main file.
 * 
 * The configuration file is typically processed during Context 
 * initialization. In a Servlet environment, this is done from
 * the ServletContextInitializer, while in JUnit testing it is 
 * done during test setup (unless you are testing configuration
 * in which case it is part of the test itself). This occurs 
 * during init() processing and is inheritly synchronized.
 * 
 * Initialization is a two step process. First create an
 * instance of this class, then find a path to the configuration
 * file and call loadConfigObjects().
 * 
 * In addition to the option of loading external classes that
 * implement one of the Plugin service interfaces by providing
 * the name of the class in the type= attribute of the Plugin
 * configuration XML, there is also a manual wiring interface.
 * Create an implimenting object yourself, then add it to the
 * configuration by passing an identifying URI and the object 
 * to a addOrReplaceXXXImplementation() method.
 * 
 * These wiring calls are agressive, while the XML is passive.
 * If the wiring call is made before loadConfigObject(), then
 * XML referencing this same URI will find that it has already
 * been loaded and use it. Alternately, if the call is made
 * after loadConfigObject() then the XML will have processed
 * the URI, loaded the file, and built an implimenting object.
 * However, the wiring call will replace that object with the
 * one provided in the call. Obviously making these calls 
 * first will be slightly more efficient, and is necessary if
 * the XML configuration specifies URIs that will be provided
 * by the wiring call and are not represented by any actual file.
 * 
 * After initialization completes, this object and its arrays
 * and collections should be structurally immutable. A map or
 * array should not be changed by adding or removing members.
 * Thus iteration over the collections can be unsynchronized.
 * The reference to a value in the map can be swapped for a 
 * new object, because this doesn't effect iteration.
 * 
 * Any method may obtain a copy of the current ServiceProviderConfig
 * object by calling ServiceProviderContext.getServiceProviderConfig().
 * This reference should only be held locally (for the duration
 * of the request). Should the entire Shibboleth configuration file 
 * be reparsed (because of a dynamic update), then a new reference will
 * be stored in the SPContext. Picking up a new reference for each
 * request ensures that a program uses the latest configuration.
 * 
 * When a secondary file (Metadata, Trust, AAP, etc.) is reloaded,
 * a new object is constructed for that interface and the entry in
 * the corresponding Map of providers of that interface is replaced.
 * Therefore, non-local variables must only store the URI for such
 * objects. A method can pass the URI to the Map lookup method and
 * obtain a local variable reference to the current implementing
 * object which can be used during the processing of the current
 * request. 
 * 
 * Note: The URI for a secondary file cannot change just by 
 * reloading the file, but it can change if this main configuration
 * file object is rebuilt. Therefore, if an external object stores
 * a URI for a plugin object, it must be prepared for the Map lookup
 * to return null. This would indicate that the main configuration 
 * file has been reloaded and the previously valid URI now no longer
 * points to any implementing object.
 * 
 * XML configuration data is parsed into two formats. First, it 
 * is processed by an ordinary JAXP XML parser into a W3C DOM format.
 * The parser may validate the XML against an XSD schema, but the 
 * resulting DOM is "untyped". The XML becomes a tree of Element,
 * Attribute, and Text nodes. The program must still convert an
 * attribute or text string to a number, date, boolean, or any other
 * data type even through the XSD declares that it must be of that 
 * type. The program must also search through the elements of the tree
 * to find specific names for expected contents.
 * 
 * This module then subjects the DOM to a secondary parse through
 * some classes generated by compiling the XSD file with tools 
 * provided by the Apache XML Bean project. This turns the valid
 * XML into strongly typed Java objects. A class is generated to
 * represent every data type defined in the XSD schemas. Attribute
 * values and child elements become properties of the objects of
 * these classes. The XMLBean objects simplify the configuration 
 * logic.
 * 
 * If the configuration file directly reflected the program logic,
 * the XML Bean classes would probably be enough. However, there
 * are two important considerations:
 * 
 * First, the Metadata is in transition. Currently we support an
 * ad-hoc format defined by Shibboleth. However, it is expected
 * that this will change in the next release to support a new
 * standard accompanying SAML 2.0. The program logic anticipates
 * this change, and is largely designed around concepts and 
 * structures of the new SAML standard. The actual configuration 
 * file and XML Beans support the old format, which must be mapped
 * into this new structure.
 * 
 * Second, secondary configuration elements (Credentials, Trust,
 * Metadata, AAP, etc.) are "Pluggable" components. There is a 
 * built-in implementation of these services based on the XML
 * configuration described in the Shibboleth documentation. 
 * However, the administrator can provide other classes that 
 * implement the required interfaces by simply coding the class
 * name in the type= parameter of the XML element referencing the
 * plugin. In this case we don't know the format of the opaque
 * XML and simply pass it to the plugin. 
 * 
 * 
 * Dependencies: Requires XML Beans and the generated classes.
 * Requires access to XSD schema files for configuration file formats.
 * Logic depends on the order of enums in the XSD files.
 * 
 * Error Strategy: A failure parsing the main configuration file
 * prevents further processing. However, a problem parsing a plug-in
 * configuration file should be noted while processing continues.
 * This strategy reports all the errors in all the files to the log
 * rather than stopping at the first error.
 */

package edu.internet2.middleware.shibboleth.serviceprovider;

import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;
import java.security.cert.X509Certificate;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.Map;
import java.util.TreeMap;

import org.apache.log4j.Logger;
import org.apache.log4j.PropertyConfigurator;
import org.apache.xmlbeans.XmlException;
import org.apache.xmlbeans.XmlOptions;
import org.opensaml.SAMLAssertion;
import org.opensaml.SAMLAttribute;
import org.opensaml.SAMLAttributeStatement;
import org.opensaml.SAMLException;
import org.opensaml.SAMLSignedObject;
import org.opensaml.artifact.Artifact;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.xml.sax.SAXException;

import x0.maceShibboleth1.AttributeAcceptancePolicyDocument;
import x0.maceShibbolethTargetConfig1.ApplicationDocument;
import x0.maceShibbolethTargetConfig1.GlobalConfigurationType;
import x0.maceShibbolethTargetConfig1.LocalConfigurationType;
import x0.maceShibbolethTargetConfig1.PluggableType;
import x0.maceShibbolethTargetConfig1.RequestMapDocument;
import x0.maceShibbolethTargetConfig1.SPConfigDocument;
import x0.maceShibbolethTargetConfig1.SPConfigType;
import x0.maceShibbolethTargetConfig1.ShibbolethTargetConfigDocument;
import x0.maceShibbolethTargetConfig1.ApplicationDocument.Application;
import x0.maceShibbolethTargetConfig1.ApplicationsDocument.Applications;
import x0.maceShibbolethTargetConfig1.CredentialUseDocument.CredentialUse;
import x0.maceShibbolethTargetConfig1.CredentialUseDocument.CredentialUse.RelyingParty;
import x0.maceShibbolethTargetConfig1.HostDocument.Host;
import x0.maceShibbolethTargetConfig1.HostDocument.Host.Scheme.Enum;
import x0.maceShibbolethTargetConfig1.PathDocument.Path;
import x0.maceShibbolethTargetConfig1.SessionsDocument.Sessions;
import edu.internet2.middleware.shibboleth.aap.AAP;
import edu.internet2.middleware.shibboleth.aap.AttributeRule;
import edu.internet2.middleware.shibboleth.aap.provider.XMLAAPProvider;
import edu.internet2.middleware.shibboleth.common.Credentials;
import edu.internet2.middleware.shibboleth.common.PluggableConfigurationComponent;
import edu.internet2.middleware.shibboleth.common.ShibbolethConfigurationException;
import edu.internet2.middleware.shibboleth.common.Trust;
import edu.internet2.middleware.shibboleth.common.provider.ShibbolethTrust;
import edu.internet2.middleware.shibboleth.metadata.EntitiesDescriptor;
import edu.internet2.middleware.shibboleth.metadata.EntityDescriptor;
import edu.internet2.middleware.shibboleth.metadata.Metadata;
import edu.internet2.middleware.shibboleth.metadata.RoleDescriptor;
import edu.internet2.middleware.shibboleth.metadata.provider.XMLMetadataProvider;
import edu.internet2.middleware.shibboleth.xml.Parser;

/**
 * Load the configuration files into objects, index them, and return them on request.
 * 
 * <p>A new instance of the ServiceProviderConfig object can be created to 
 * parse a new version of the configuration file. It can then be swapped
 * into the ServiceProviderContext reference and will be picked up by
 * subsequent requests.</p>
 * 
 * @author Howard Gilbert
 */
public class ServiceProviderConfig {

	// Map key prefix for inline plugin configuration elements 
	private static final String INLINEURN = "urn:inlineBS:ID";
    
    private static Logger initlog = Logger.getLogger(ContextListener.SHIBBOLETH_INIT+".Config");
    private static Logger reqlog = Logger.getLogger(ServiceProviderConfig.class);

	private SPConfigType  // The XMLBean from the main config file
		config = null;    
	
	
	/*
	 * The following Maps reference objects that implement a plugin
	 * interface indexed by their URI. There are builtin objects
	 * created from inline or external XML files, but external 
	 * objects implementing the interfaces may be injected by 
	 * calling the addOrReplaceXXX method. Public access to these
	 * Maps is indirect, through methods the ApplicationInfo object
	 * for a given configured or default application.
	 */
	
	private Map/*<String, Metadata>*/ entityLocators = 
		new TreeMap/*<String, Metadata>*/();
	
	public void addOrReplaceMetadataImplementor(String uri, Metadata m) {
		initlog.info("addOrReplaceMetadataImplementor " + uri+ " as "+m.getClass());
	    entityLocators.put(uri, m);
	}
	
	public Metadata getMetadataImplementor(String uri) {
	    return (Metadata)entityLocators.get(uri);
	}
	
	private Map/*<String, AAP>*/ attributePolicies = 
		new TreeMap/*<String, AAP>*/();
	
	public void addOrReplaceAAPImplementor(String uri, AAP a) {
		initlog.info("addOrReplaceAAPImplementor " + uri+ " as "+a.getClass());
	    attributePolicies.put(uri,a);
	}
	
	public AAP getAAPImplementor(String uri) {
	    return (AAP) attributePolicies.get(uri);
	}
	
	private Map/*<String, Trust>*/ certificateValidators = 
		new TreeMap/*<String, Trust>*/();
	
	public void addOrReplaceTrustImplementor(String uri, Trust t) {
		initlog.info("addOrReplaceTrustImplementor " + uri+ " as "+t.getClass());
	    certificateValidators.put(uri,t);
	}
	
	public Trust getTrustImplementor(String uri) {
	    return (Trust) certificateValidators.get(uri);
	}
	
	private Trust[] defaultTrust = {new ShibbolethTrust()};
	
	/*
	 * Objects created from the <Application(s)> elements.
	 * They manage collections of URI-Strings that index the
	 * previous maps to return Metadata, Trust, and AAP info
	 * applicable to this applicationId.
	 */
	private Map/*<String, ApplicationInfo>*/ applications = 
		new TreeMap/*<String, ApplicationInfo>*/();
	
	// Default application info from <Applications> element
	private ApplicationInfo defaultApplicationInfo = null;

    public ApplicationInfo getApplication(String applicationId) {
    	ApplicationInfo app=null;
    	app = (ApplicationInfo) applications.get(applicationId);
    	if (app==null)  // If no specific match, return default
    		return defaultApplicationInfo;
    	return app;
    }
	
	
	// Objects created from single configuration file elements
	private Credentials credentials = null;
	private RequestMapDocument.RequestMap requestMap = null;
	
	
	/*
	 * A few constants
	 */

	private static final String XMLTRUSTPROVIDERTYPE = 
		"edu.internet2.middleware.shibboleth.common.provider.ShibbolethTrust";
	private static final String XMLAAPPROVIDERTYPE = 
		"edu.internet2.middleware.shibboleth.aap.provider.XMLAAP";
	private static final String XMLFEDERATIONPROVIDERTYPE = 
		"edu.internet2.middleware.shibboleth.metadata.provider.XMLMetadata";
	private static final String XMLREQUESTMAPPROVIDERTYPE = 
	    "edu.internet2.middleware.shibboleth.sp.provider.NativeRequestMapProvider";
	private static final String XMLCREDENTIALSPROVIDERTYPE = 
	    "edu.internet2.middleware.shibboleth.common.Credentials";
	
	
	
	
	/**
	 * The constructor prepares for, but does not parse the configuration.
	 * 
	 * @throws ShibbolethConfigurationException
	 * 	  if XML Parser cannot be initialized (Classpath problem)
	 */
	public ServiceProviderConfig() {
	}

	/**
	 * loadConfigObjects must be called once to parse the configuration.
	 * 
	 * <p>To reload a modified configuration file, create and load a second 
	 * object and swap the reference in the context object.</p>
	 * 
	 * @param configFilePath URL or resource name of file
	 * @return the DOM Document
	 * @throws ShibbolethConfigurationException
	 *             if there was an error loading the file
	 */
	public synchronized void loadConfigObjects(String configFilePath)
			throws ShibbolethConfigurationException {
	    
	    if (config!=null) {
			initlog.error("ServiceProviderConfig.loadConfigObjects may not be called twice for the same object.");
			throw new ShibbolethConfigurationException("Cannot reload configuration into same object.");
		}
	    
	    initlog.info("Loading SP configuration from "+configFilePath);

		Document configDoc;
		try {
			configDoc = Parser.loadDom(configFilePath, true);
			if (configDoc==null) {
				initlog.error("Cannot load configuration file from "+configFilePath);
				throw new ShibbolethConfigurationException("Cannot load configuration file from "+configFilePath);
			}
		} catch (SAMLException e) {
			throw new ShibbolethConfigurationException("Problem obtaining XML parser from SAML "+e.toString());
		} catch (IOException e) {
			throw new ShibbolethConfigurationException("Problem reading file parsing "+configFilePath, e);
		} catch (SAXException e) {
			throw new ShibbolethConfigurationException("Problem parsing XML in "+configFilePath, e);
		}
        loadConfigBean(configDoc);
        
		return;
	}
    
    public long getDefaultAttributeLifetime() {
        return config.getGlobal().getMemorySessionCache().getDefaultLifetime();
    }

    public long getAAConnectTimeout() {
        return config.getGlobal().getMemorySessionCache().getAAConnectTimeout();
    }
    public long getAATimeout() {
        return config.getGlobal().getMemorySessionCache().getAATimeout();
    }
    
    
	/*
	 * Given a URL, determine its ApplicationId from the RequestMap config.
	 * 
	 * <p>Note: This is not a full implementation of all RequestMap
	 * configuration options. Other functions will be added as needed.</p>
	 */
	public String mapRequest(String urlreq) {
	    String applicationId = "default";
	    URL url;
	    
	    try {
            url = new URL(urlreq);
        } catch (MalformedURLException e) {
            return applicationId;
        }
        
        String urlscheme = url.getProtocol();
        String urlhostname = url.getHost();
        String urlpath = url.getPath();
        int urlport = url.getPort();
        
        // find Host entry for this virtual server
        Host[] hostArray = requestMap.getHostArray();
        for (int ihost=0;ihost<hostArray.length;ihost++) {
            Host host = hostArray[ihost];
            Enum scheme = host.getScheme();
            String hostName = host.getName();
            String hostApplicationId = host.getApplicationId();
            long hostport = host.getPort();
            
            if (scheme != null &&
                !urlscheme.equals(scheme.toString()))
                continue;
            if (!urlhostname.equals(hostName))
                continue;
            if (hostport!=0 &&
                urlport!=0 &&    
                urlport!=hostport)
                continue;
            
            // find Path entry for this subdirectory
            Path[] pathArray = host.getPathArray();
            if (hostApplicationId!=null)
                applicationId=hostApplicationId;
            for (int i=0;i<pathArray.length;i++) {
                String dirname = pathArray[i].getName();
                if (urlpath.equals(dirname)||
                    urlpath.startsWith(dirname+"/")){
                    String pthid= pathArray[i].getApplicationId();
                    if (pthid!=null)
                        applicationId=pthid;
                }
            }
        }
	    
        reqlog.debug("mapRequest mapped "+urlreq+" into "+applicationId);
	    return applicationId;
	}

	/**
	 * <p>Parse the main configuration file DOM into XML Bean</p>
	 * 
	 * <p>Automatically load secondary configuration files designated
	 * by URLs in the main configuration file</p>
	 * 
	 * @throws ShibbolethConfigurationException
	 */
	private void loadConfigBean(Document configDoc) 
		throws ShibbolethConfigurationException {
	    boolean anyError=false;
		
		Element documentElement = configDoc.getDocumentElement();
		// reprocess the already validated DOM to create a bean with typed fields
		// dump the trash (comments, processing instructions, extra whitespace)
		try {
			if (documentElement.getLocalName().equals("ShibbolethTargetConfig")) {
				initlog.debug("SP Configuration file is in 1.2 syntax.");
				ShibbolethTargetConfigDocument configBeanDoc;
				configBeanDoc = ShibbolethTargetConfigDocument.Factory.parse(configDoc,
						new XmlOptions().setLoadStripComments().setLoadStripProcinsts().setLoadStripWhitespace());
				config = configBeanDoc.getShibbolethTargetConfig();
			} else if (documentElement.getLocalName().equals("SPConfig")) {
				initlog.debug("SP Configuration file is in 1.3 syntax.");
				SPConfigDocument configBeanDoc;
				configBeanDoc = SPConfigDocument.Factory.parse(configDoc,
						new XmlOptions().setLoadStripComments().setLoadStripProcinsts().setLoadStripWhitespace());
				config = configBeanDoc.getSPConfig();
			} else {
				initlog.error("Root element not ShibbolethTargetConfig or SPConfig");
				throw new XmlException("Root element not ShibbolethTargetConfig or SPConfig");
			}
		} catch (XmlException e) {
			// Since the DOM was already validated against the schema, errors will not typically occur here
			initlog.error("Error while parsing shibboleth configuration");
			throw new ShibbolethConfigurationException("Error while parsing shibboleth configuration");
		}
		
		String loggerUrlString = config.getLogger();
		if (loggerUrlString!=null) {
			try {
				URL loggerURL = new URL(loggerUrlString);
				initlog.warn("logging is being reconfigured by "+ loggerUrlString);
				PropertyConfigurator.configure(loggerURL);
			} catch (MalformedURLException e) {
				// This error is not serious enough to prevent initialization
				initlog.error("Ignoring invalid value for logger attribute "+loggerUrlString );
			}
		}
		
		Applications apps = config.getApplications(); // <Applications>
		
		
		
		/*
		 * Create an <Application> id "default" from <Applications>
		 */
		ApplicationDocument defaultAppDoc = 
		    // Create a new XMLBeans "Document" level object
			ApplicationDocument.Factory.newInstance(); 
		ApplicationDocument.Application defaultApp = 
		    // Add an XMLBeans "root Element" object to the Document
			defaultAppDoc.addNewApplication();
		// set or copy over fields from unrelated Applications object
		defaultApp.setId("default");
		defaultApp.setAAPProviderArray(apps.getAAPProviderArray());
		defaultApp.setAttributeDesignatorArray(apps.getAttributeDesignatorArray());
		defaultApp.setAudienceArray(apps.getAudienceArray());
		defaultApp.setCredentialUse(apps.getCredentialUse());
		defaultApp.setErrors(apps.getErrors());
		defaultApp.setFederationProviderArray(apps.getFederationProviderArray());
		defaultApp.setMetadataProviderArray(apps.getMetadataProviderArray());
		defaultApp.setProviderId(apps.getProviderId());
		defaultApp.setSessions(apps.getSessions());
		defaultApp.setTrustProviderArray(apps.getTrustProviderArray());
		
		/*
		 * Now process secondary files configured in the applications
		 */
		anyError |= processApplication(defaultApp);
		
		Application[] apparray = apps.getApplicationArray();
		for (int i=0;i<apparray.length;i++){
			Application tempapp = apparray[i];
			applications.put(tempapp.getId(),tempapp);
			anyError |= processApplication(tempapp);
		}
		
		/*
		 * Now process other secondary files
		 */
		anyError |= processCredentials();
		anyError |= processPluggableRequestMapProvider();
		
		if (anyError) {
			initlog.error("SP Initialization terminated due to configuration errors");
		    throw new ShibbolethConfigurationException("Errors processing configuration file, see log");
		}
	}

	
	/**
	 * Routine to handle CredentialProvider
	 * 
	 * <p>Note: This only handles in-line XML.
	 * Also, Credentials was an existing IdP class, so it doesn't
	 * implement the new PluggableConfigurationComponent interface and
	 * can't be loaded by generic plugin support.
	 * </p>
	 */
	private boolean processCredentials() {
	    boolean anyError=false;
	    PluggableType[] pluggable = config.getCredentialsProviderArray();
	    for (int i=0;i<pluggable.length;i++) {
			String pluggabletype = pluggable[i].getType();
	        if (!pluggabletype.equals(
	        	"edu.internet2.middleware.shibboleth.common.Credentials")) {
				initlog.error("Unsupported CredentialsProvider type "+pluggabletype);
				anyError=true;
				continue;
	        }
        	PluggableType credentialsProvider = pluggable[i];
            Node fragment = credentialsProvider.newDomNode();
            // newDomNode returns the current node wrapped in a Fragment
            try {
                Node credentialsProviderNode = fragment.getFirstChild();
                Node credentialsNode=credentialsProviderNode.getFirstChild();
                credentials = new Credentials((Element)credentialsNode);
            } catch(Exception e) {
                initlog.error("Cannot process Credentials element of Shibboleth configuration",e);
                anyError=true;
                continue;
            }
	    }
	    return anyError;
	}

    /**
	 * Find and load secondary configuration files referenced in an Application(s) 
	 * 
	 * @param app Application object
	 * @throws ShibbolethConfigurationException
	 */
	private boolean processApplication(Application app) 
		throws ShibbolethConfigurationException {
	    
	    boolean anyError=false;
	    
	    String applicationId = app.getId();
		
		ApplicationInfo appinfo = new ApplicationInfo(app);
		
		anyError |= processPluggableMetadata(appinfo);
		anyError |= processPluggableAAPs(appinfo);
		anyError |= processPluggableTrusts(appinfo);
		
		applications.put(applicationId, appinfo);
		
		return anyError;
	}

    /**
     * Generic code to create an object of a Pluggable type that implements
     * a configuration interface.
     * 
     * <p>The configuration schema defines "PluggableType" as a type of
     * XML element that has opaque contents and attributes "type" and 
     * "uri". If the uri attribute is omitted, then the configuration
     * data is inline XML content. The XSD files typically define the
     * format of pluggable configuration elements, but without binding
     * them to the PluggableType element that may contain them.</p>
     * 
     * <p>The implimentation of pluggable objects is provided by 
     * external classes. There are "builtin" classes provided with
     * Shibboleth (XMLMetadataImpl, XMLTrustImpl, XMLAAPImpl) that 
     * provide examples of how this is done. By design, others can
     * provide their own classes just by putting the class name as
     * the value of the type attribute.</p>
     * 
     * <p>This routine handles the common setup. It creates objects
     * of one of the builtin types, or it uses Class.forName() to
     * access a user specified class. It then locates either the
     * inline XML elements or the external XML file. It passes the
     * XML to initialize the object. Finally, a reference to the 
     * object is stored in the appropriate Map.</p>
     * 
     * <p>The objects created implement two interfaces. Mostly they
     * implement a configuration interface (EntityDescriptor, Trust,
     * AAP, etc). However, for the purpose of this routine they also
     * must be declared to implement PluggableConfigurationComponent
     * and provide an initialize() method that parses a DOM Node 
     * containing their root XML configuration element.</p>
     * 
     * @param pluggable XMLBean for element defined in XSD to be of "PluggableType"
     * @param implclass java.lang.Class of Builtin implementation class
     * @param interfaceClass java.lang.Class of Interface
     * @param builtinName alias type to choose Builtin imlementation
     * @param uriMap ApplicationInfo Map for this interface
     * @return
     */
    private 
    	String 
    processPluggable(
            PluggableType pluggable,
    		Class implclass,
    		Class interfaceClass,
    		String builtinName,
    		Map /*<String,PluggableConfigurationComponent>*/uriMap
    		) {
        
    	String pluggabletype = pluggable.getType();
    	
    	if (!pluggabletype.equals(builtinName)) {
    	    // Not the builtin type, try to load user class by name
    		initlog.info("loading user-specified pluggable class "+pluggabletype);
    	    try {
                implclass = Class.forName(pluggabletype);
            } catch (ClassNotFoundException e) {
    			initlog.error("Type value "+pluggabletype+" not found as supplied Java class");
    		    return null;
            }
    	    if (!interfaceClass.isAssignableFrom(implclass)||
                !PluggableConfigurationComponent.class.isAssignableFrom(implclass)) {
	    		initlog.error(pluggabletype+" class does not support required interfaces.");
	    	    return null;
    	    }
    	}
    	
    	PluggableConfigurationComponent impl;
        try {
            impl = (PluggableConfigurationComponent) implclass.newInstance();
        } catch (Exception e) {
            initlog.error("Unable to instantiate "+pluggabletype);
            return null;
        }
    	
    	String uri = pluggable.getUri();
    	if (uri==null) { // inline
    	    
    		uri=genDummyUri();
    		try {
    			Node fragment = pluggable.newDomNode();        // XML-Fragment node
    			Node pluggableNode = fragment.getFirstChild(); // PluggableType 
    			Element contentNode=(Element) pluggableNode.getFirstChild();// root element
    			impl.initialize(contentNode);
    		} catch (Exception e) {
    			initlog.error("XML error " + e);
    			return null;
    		}
    		
    	} else { // external file
    		
    		if (uriMap.get(uri)!=null) { // Already parsed this file
    		    return "";
    		}
    		
    		try {
    			Document extdoc = Parser.loadDom(uri,true);
    			if (extdoc==null)
    			    return null;
    			impl.initialize(extdoc.getDocumentElement());
    		} catch (Exception e) {
    			initlog.error("XML error " + e);
    			return null;
    		}
    	}
    	
    	uriMap.put(uri,impl);
    	return uri;
    }
	
	

	/**
	 * Handle a FederationProvider 
	 */
	private boolean processPluggableMetadata(ApplicationInfo appinfo) {
	    boolean anyError = false;
		PluggableType[] pluggable1 = appinfo.getApplicationConfig().getFederationProviderArray();
		PluggableType[] pluggable2 = appinfo.getApplicationConfig().getMetadataProviderArray();
		PluggableType[] pluggable;
		if (pluggable1.length==0) {
			pluggable=pluggable2;
		} else if (pluggable2.length==0) {
			pluggable=pluggable1;
		} else {
			pluggable = new PluggableType[pluggable1.length+pluggable2.length];
			for (int i=0;i<pluggable2.length;i++) {
				pluggable[i]=pluggable2[i];
			}
			for (int i=0;i<pluggable1.length;i++) {
				pluggable[i+pluggable2.length]=pluggable1[i];
			}
		}
		for (int i = 0;i<pluggable.length;i++) {
		    String uri = processPluggable(pluggable[i],
		            XMLMetadataProvider.class,
		            Metadata.class,
		            XMLFEDERATIONPROVIDERTYPE,
		            entityLocators);
		    if (uri==null)
		        anyError=true;
		    else if (uri.length()>0) {
				appinfo.addGroupUri(uri);
		    }
		}
		return anyError;
	}
	
	/**
	 * Reload XML Metadata configuration after file changed.
	 * @param uri Path to Metadata XML configuration
	 * @return true if file reloaded.
	 */
	public boolean reloadFederation(String uri) {
	    if (getMetadataImplementor(uri)!=null||
	            uri.startsWith(INLINEURN))
	        return false;
		try {
			Document sitedoc = Parser.loadDom(uri,true);
			if (sitedoc==null)
			    return false;
			XMLMetadataProvider impl = new XMLMetadataProvider();
			impl.initialize(sitedoc.getDocumentElement());
			addOrReplaceMetadataImplementor(uri,impl);
		} catch (Exception e) {
			initlog.error("Error while parsing Metadata file "+uri);
			initlog.error("XML error " + e);
			return false;
		}
	    return true;
	}

	/**
	 * Handle an AAPProvider element with
	 *      type="edu.internet2.middleware.shibboleth.common.provider.XMLAAP"
	 * @throws InternalConfigurationException
	 */
	private boolean processPluggableAAPs(ApplicationInfo appinfo){
	    boolean anyError=false;
		PluggableType[] pluggable = appinfo.getApplicationConfig().getAAPProviderArray();
		for (int i = 0;i<pluggable.length;i++) {
		    String uri = processPluggable(pluggable[i],
		    		XMLAAPProvider.class,
		            AAP.class,
		            XMLAAPPROVIDERTYPE,
		            attributePolicies);
		    if (uri==null)
		        anyError=true;
		    else if (uri.length()>0) {
				appinfo.addAapUri(uri);
		    }
		}
		return anyError;
	}
	
	/**
	 * Reload XML AAP configuration after file changed.
	 * @param uri AAP to Trust XML configuration
	 * @return true if file reloaded.
	 */
	public boolean reloadAAP(String uri) {
	    if (getAAPImplementor(uri)!=null||
	            uri.startsWith(INLINEURN))
	        return false;
		try {
			Document aapdoc = Parser.loadDom(uri,true);
			if (aapdoc==null)
			    return false;
			XMLAAPProvider impl = new XMLAAPProvider();
			impl.initialize(aapdoc.getDocumentElement());
			addOrReplaceAAPImplementor(uri,impl);
		} catch (Exception e) {
			initlog.error("Error while parsing AAP file "+uri);
			initlog.error("XML error " + e);
			return false;
		}
	    return true;
	}
	
	
	/**
	 * Handle a TrustProvider element with
	 *      type="edu.internet2.middleware.shibboleth.common.provider.XMLTrust"
	 * 
	 * Note: This code builds the semantic structure of trust. That is, it knows
	 * about certificates and keys. The actual logic of Trust (signature generation
	 * and validation) is implemented in a peer object defined in the external
	 * class XMLTrustImpl.
	 * 
	 * @throws ShibbolethConfigurationException if X.509 certificate cannot be processed 
	 * @throws InternalConfigurationException
	 */
	private boolean processPluggableTrusts(ApplicationInfo appinfo){
	    boolean anyError=false;
		PluggableType[] pluggable = appinfo.getApplicationConfig().getTrustProviderArray();
		for (int i = 0;i<pluggable.length;i++) {
		    String uri = processPluggable(pluggable[i],
		            ShibbolethTrust.class,
		            Trust.class,
		            XMLTRUSTPROVIDERTYPE,
		            certificateValidators);
		    if (uri==null)
		        anyError=true;
		    else if (uri.length()>0) {
				appinfo.addTrustUri(uri);
		    }
		}
		return anyError;
	}

	
	
	private boolean processPluggableRequestMapProvider(){
	    LocalConfigurationType shire = config.getSHIRE();
        if (shire==null)
            shire = config.getLocal();
        if (shire==null) {
            initlog.error("No SHIRE or Local element.");
            return true;
        }
	    PluggableType mapProvider = shire.getRequestMapProvider();
	    
	    String pluggabletype = mapProvider.getType();
	    if (!pluggabletype.equals(XMLREQUESTMAPPROVIDERTYPE)) {
	        initlog.error("Unsupported RequestMapProvider type "+pluggabletype);
	        return true;
	    }
	    
	    RequestMapDocument requestMapDoc = null;
	    Document mapdoc = null;
	    String uri = mapProvider.getUri();
	    
	    if (uri==null) { // inline
	        
	        uri=genDummyUri();
	        try {
	            Node fragment = mapProvider.newDomNode();
	            Node pluggableNode = fragment.getFirstChild();
	            Node contentNode=pluggableNode.getFirstChild();
	            
	            requestMapDoc = RequestMapDocument.Factory.parse(contentNode);
	        } catch (Exception e) {
	            initlog.error("Error while parsing inline RequestMap");
	            initlog.error("XML error " + e);
	            return true;
	        }
	        
	    } else { // external file
	        try {
	            mapdoc = Parser.loadDom(uri,true);
	            if (mapdoc==null)
	                return true;
	            requestMapDoc = RequestMapDocument.Factory.parse(mapdoc);
	        } catch (Exception e) {
	            initlog.error("Error while parsing RequestMap file "+uri);
	            initlog.error("XML error " + e);
	            return true;
	        }
	    }
	    
	    requestMap = requestMapDoc.getRequestMap();
	    return false;
	}

	
	// Generate Map keys for inline plugin configuration Elements
	private int inlinenum = 1;
	private String genDummyUri() {
		return INLINEURN+Integer.toString(inlinenum++);
	}
	
	
	



    /**
	 * ApplicationInfo represents the <Application(s)> object, its fields,
	 * and the pluggable configuration elements under it.
	 * 
	 * <p>It can return arrays of Metadata, Trust, or AAP providers, but
	 * it also exposes convenience methods that shop the lookup(),
	 * validate(), and trust() calls to each object in the collection
	 * until success or failure is determined.</p>
	 * 
	 * <p>For all other parameters, such as Session parameters, you
	 * can fetch the XMLBean by calling getApplicationConf() and 
	 * query their value directly.
	 */
	public class ApplicationInfo 
		implements Metadata, Trust {
		
		private Application applicationConfig;
        public Application getApplicationConfig() {
            return applicationConfig;
        }
		
		/**
		 * Construct this object from the XML Bean.
		 * @param application XMLBean for Application element
		 */
		ApplicationInfo(Application application) {
		    this.applicationConfig=application;
		}
		
		
		/*
		 * Following the general rule, this object may not keep 
		 * direct references to the plugin interface implementors,
		 * but must look them up on every call through their URI keys.
		 * So we keep collections of URI strings instead.
		 */
		ArrayList groupUris = new ArrayList();
		ArrayList trustUris = new ArrayList();
		ArrayList aapUris   =   new ArrayList();
		
        void addGroupUri(String uri) {
			groupUris.add(uri);
		}
		void addTrustUri(String uri) {
			trustUris.add(uri);
		}
		void addAapUri(String uri) {
			aapUris.add(uri);
		}
        
        long getMaxSessionLife() {
            Sessions sessions = applicationConfig.getSessions();
            return sessions.getLifetime();
        }
        long getUnusedSessionTimeout() {
            Sessions sessions = applicationConfig.getSessions();
            return sessions.getTimeout();
        }
        
        /**
         * Given the EntityDescriptor of an IdP, find the RelyingParty
         * element of the CredentialsUse section that matches the 
         * Entity name or one of its parent group names and return
         * the signing credential that should be used with it. If
         * no specific match occurs, return the default siging
         * credential. 
         * 
         * @param entity
         * @return
         */
        String getCredentialIdForEntity(EntityDescriptor entity) {
            
            // Get the ID URI of the Entity and all its parent groups
            EntitiesDescriptor entitiesDescriptor = entity.getEntitiesDescriptor();
            ArrayList idlist = new ArrayList();
            idlist.add(entity.getId());
            // An EntityDescriptor must have a name, while groups may have names
            while (entitiesDescriptor!=null) {
                String edname = entitiesDescriptor.getName();
                if (edname!=null)
                    idlist.add(edname);
                // Chain up to parent Element, until none left
                entitiesDescriptor=entitiesDescriptor.getEntitiesDescriptor();
            }
            
            // Get the default signing Credential ID and the RelyingParty overrides
            CredentialUse credentialUse = applicationConfig.getCredentialUse();
            if (credentialUse==null) {
                // An <Application> may not have one, so look to the enclosing <Applications>
                credentialUse = defaultApplicationInfo.applicationConfig.getCredentialUse();
            }
            if (credentialUse == null)
                return null;  // If there is no CredentialsUse there is no signing
            String defaultCredentialId = credentialUse.getSigning();
            // If no signing= attribute (null), then don't sign
            RelyingParty[] relyingPartyArray = credentialUse.getRelyingPartyArray();

            // Search for a match of Entity/Group ID against an overriding RelyingParty
            Iterator iterator = idlist.iterator();
            while (iterator.hasNext()) {
                String id = (String) iterator.next();
                for (int i =0;i<relyingPartyArray.length;i++) {
                    if (relyingPartyArray[i].getName().equals(id)) {
                        // We have matched a RelyingParty override 
                        String signingCredName = relyingPartyArray[i].getSigning();
                        // If no signing= attribute (null), then don't sign
                        return signingCredName;
                    }
                }
            }
            // No RelyingParty match, so use the default
            return defaultCredentialId;
        }
        
		/**
		 * Return the current array of objects that implement the
		 * ...metadata.Metadata interface
		 * 
		 * @return Metadata[]
		 */
		Metadata[] getMetadataProviders() {
			Iterator iuris = groupUris.iterator();
			int count = groupUris.size();
			Metadata[] metadatas = new Metadata[count];
			for (int i=0;i<count;i++) {
				String uri =(String) iuris.next();
				metadatas[i]=getMetadataImplementor(uri);
			}
			return metadatas;
		}
		
		/**
		 * A convenience function based on the Metadata interface.
		 * 
		 * <p>Look for an entity ID through each implementor until the
		 * first one finds locates a describing object.</p>
		 * 
		 * <p>Unfortunately, Metadata.lookup() was originally specified to
		 * return a "Provider". In current SAML 2.0 terms, the object
		 * returned should be an EntityDescriptor. So this is the new 
		 * function in the new interface that will use the new term, but
		 * it does the same thing.</p>
		 *  
		 * @param id ID of the IdP entity
		 * @return EntityDescriptor metadata object for that site.
		 */
        public EntityDescriptor lookup(String id, boolean strict) {
			Iterator iuris = groupUris.iterator();
			while (iuris.hasNext()) {
				String uri =(String) iuris.next();
				Metadata locator=getMetadataImplementor(uri);
				EntityDescriptor entity = locator.lookup(id, strict);
				if (entity!=null) {
					reqlog.debug("Metadata.lookup resolved Entity "+ id);
					return entity;
				}
			}
			reqlog.warn("Metadata.lookup failed to resolve Entity "+ id);
			return null;
		}

        public EntityDescriptor lookup(Artifact artifact, boolean strict) {
            Iterator iuris = groupUris.iterator();
            while (iuris.hasNext()) {
                String uri =(String) iuris.next();
                Metadata locator=getMetadataImplementor(uri);
                EntityDescriptor entity = locator.lookup(artifact, strict);
                if (entity!=null) {
					reqlog.debug("Metadata.lookup resolved Artifact "+ artifact);
                    return entity;
                }
            }
			reqlog.warn("Metadata.lookup failed to resolve Artifact "+ artifact);
            return null;
        }

		public EntityDescriptor lookup(String id) {
			return lookup(id,true);
		}

		public EntityDescriptor lookup(Artifact artifact) {
			return lookup(artifact,true);
		}

		public EntityDescriptor getRootEntity() {
			return null;
		}

		public EntitiesDescriptor getRootEntities() {
			return null;
		}
        
		/**
		 * Return the current array of objects that implement the Trust interface
		 * 
		 * @return Trust[]
		 */
		public Trust[] getTrustProviders() {
			Iterator iuris = trustUris.iterator();
			int count = trustUris.size();
			if (count==0)
				return defaultTrust;
			Trust[] trusts = new Trust[count];
			for (int i=0;i<count;i++) {
				String uri =(String) iuris.next();
				trusts[i]=getTrustImplementor(uri);
			}
			return trusts;
		}
		
		/**
		 * Return the current array of objects that implement the AAP interface
		 * 
		 * @return AAP[]
		 */
		public AAP[] getAAPProviders() {
			Iterator iuris = aapUris.iterator();
			int count = aapUris.size();
			AAP[] aaps = new AAP[count];
			for (int i=0;i<count;i++) {
				String uri =(String) iuris.next();
				aaps[i]=getAAPImplementor(uri);
			}
			return aaps;
		}
		
		/**
		 * Convenience function to apply AAP by calling the apply()
		 * method of each AAP implementor.
		 * 
		 * <p>Any AAP implementor can delete an assertion or value.
		 * Empty SAML elements get removed from the assertion.
		 * This can yield an AttributeAssertion with no attributes. 
		 * 
		 * @param assertion  SAML Attribute Assertion
         * @param role     Role that issued the assertion
		 * @throws SAMLException  Raised if assertion is mangled beyond repair
		 */
		void applyAAP(SAMLAssertion assertion, RoleDescriptor role) throws SAMLException {
		    
		    // Foreach AAP in the collection
			AAP[] providers = getAAPProviders();
            if (providers.length == 0) {
                reqlog.info("no filters specified, accepting entire assertion");
                return;
            }
			for (int i=0;i<providers.length;i++) {
				AAP aap = providers[i];
				if (aap.anyAttribute()) {
                    reqlog.info("any attribute enabled, accepting entire assertion");
					continue;
                }
            }
            
			// Foreach Statement in the Assertion
			Iterator statements = assertion.getStatements();
            
            // Statements can be deleted out of the assertion 
            // which renders the interator invalid unless it is
            // based on a derived collection.
            ArrayList statementList = new ArrayList();
            while (statements.hasNext()) {
                statementList.add(statements.next());
            }
            statements=statementList.iterator();
			int istatement=0;
			while (statements.hasNext()) {
				Object statement = statements.next();
				if (statement instanceof SAMLAttributeStatement) {
					SAMLAttributeStatement attributeStatement =	(SAMLAttributeStatement) statement;
					
                    // Check each attribute, applying any matching rules.
					Iterator attributes = attributeStatement.getAttributes();
                    
                    // Same trick for attributes
                    ArrayList attributeList = new ArrayList();
                    while (attributes.hasNext()) {
                        attributeList.add(attributes.next());
                    }
                    attributes = attributeList.iterator();
                    
					int iattribute=0;
					while (attributes.hasNext()) {
						SAMLAttribute attribute = (SAMLAttribute) attributes.next();
                        boolean ruleFound = false;
                        for (int i=0;i<providers.length;i++) {
    						AttributeRule rule = providers[i].lookup(attribute.getName(),attribute.getNamespace());
    						if (rule!=null) {
    						    ruleFound = true;
                                try {
                                    rule.apply(attribute,role);
                                }
                                catch (SAMLException ex) {
                                    reqlog.info("no values remain, removing attribute");
        							attributeStatement.removeAttribute(iattribute--);
                                    break;
                                }
                            }
                        }
                        if (!ruleFound) {
                            reqlog.warn("no rule found for attribute (" + attribute.getName() + "), filtering it out");
                            attributeStatement.removeAttribute(iattribute--);
                        }
                        iattribute++;
					}
                    
                    try {
                        attributeStatement.checkValidity();
                        istatement++;
					}
                    catch (SAMLException ex) {
                        // The statement is now defunct.
                        reqlog.info("no attributes remain, removing statement");
						assertion.removeStatement(istatement);
					}
				}
			}

            // Now see if we trashed it irrevocably.
            assertion.checkValidity();
        }
		
		
		/**
		 * Returns a collection of attribute names to request from the AA.
		 * 
		 * @return Collection of attribute Name values
		 */
		public Collection getAttributeDesignators() {
			// TODO Not sure where this should come from
			return new ArrayList();
		}

		
		/**
		 * Convenience method implementing Trust.validate() across 
		 * the collection of implementing objects. Returns true if
		 * any Trust implementor approves the signatures in the object.
		 * 
		 * <p>In the interface, validate() is passed several arguments
		 * that come from this object. In this function, those
		 * arguments are ignored "this" is used. 
		 */
		public boolean 
		validate(
				SAMLSignedObject token, 
				RoleDescriptor role
					) {
			
	
			Trust[] trustProviders = getTrustProviders();
			for (int i=0;i<trustProviders.length;i++) {
				Trust trust = trustProviders[i];
				if (trust.validate(token,role))
					return true;
			}
			reqlog.warn("SAML object failed Trust validation.");
			return false;
		}
		

		/**
		 * A method of Trust that we must declare to claim that 
		 * ApplicationInfo implements Trust. However, no code in the
		 * ServiceProvider calls this (probably an IdP thing).
		 * 
		 * @param revocations
		 * @param role
		 * @return  This dummy always returns false.
		 */
		public boolean attach(Iterator revocations, RoleDescriptor role) {
			// Unused
			return false;
		}

		public boolean validate(X509Certificate certificateEE, X509Certificate[] certificateChain, RoleDescriptor descriptor) {
			Trust[] trustProviders = getTrustProviders();
			for (int i=0;i<trustProviders.length;i++) {
				Trust trust = trustProviders[i];
				if (trust.validate(certificateEE,certificateChain,descriptor))
					return true;
			}
			reqlog.warn("X.509 Certificate failed Trust validate");
			return false;
		}

		public boolean validate(X509Certificate certificateEE, X509Certificate[] certificateChain, RoleDescriptor descriptor, boolean checkName) {
			Trust[] trustProviders = getTrustProviders();
			for (int i=0;i<trustProviders.length;i++) {
				Trust trust = trustProviders[i];
				if (trust.validate(certificateEE,certificateChain,descriptor,checkName))
					return true;
			}
			reqlog.warn("X.509 Certificate failed Trust validate");
			return false;
		}
        
        public String getProviderId() {
            String entityId = this.applicationConfig.getProviderId();
            if (entityId==null && this!=defaultApplicationInfo) {
                entityId = defaultApplicationInfo.getProviderId();
            }
            return entityId;
        }
	}
	

	
	private static class InternalConfigurationException extends Exception {
	    InternalConfigurationException() {
	        super();
	    }
	}



    public Credentials getCredentials() {
        return credentials;
    }
	
}
